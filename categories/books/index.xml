<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Books on happyhacker的技术分享</title>
        <link>http://localhost:1313/categories/books/</link>
        <description>Recent content in Books on happyhacker的技术分享</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sat, 18 Apr 2020 17:22:43 +0800</lastBuildDate><atom:link href="http://localhost:1313/categories/books/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>《并发编程实战》读书笔记</title>
        <link>http://localhost:1313/p/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sat, 18 Apr 2020 17:22:43 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;p&gt;读书过程中看到的比较准确的定义。&lt;/p&gt;
&lt;h2 id=&#34;线程安全的类&#34;&gt;
    &lt;a href=&#34;#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e7%b1%bb&#34;&gt;#&lt;/a&gt;
    线程安全的类
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;无状态对象一定是线程安全的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;假定有两个操作A和B，如果从执行A的线程来看，当零一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说就是原子的。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;在实际情况中，应尽可能的使用现有的线程安全对象来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        
    </channel>
</rss>
